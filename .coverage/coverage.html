
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nmi: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jufemaiz/go-aemo/nmi/allocations.go (100.0%)</option>
				
				<option value="file1">github.com/jufemaiz/go-aemo/nmi/energy.go (100.0%)</option>
				
				<option value="file2">github.com/jufemaiz/go-aemo/nmi/meter.go (100.0%)</option>
				
				<option value="file3">github.com/jufemaiz/go-aemo/nmi/meterregister.go (100.0%)</option>
				
				<option value="file4">github.com/jufemaiz/go-aemo/nmi/nmi.go (100.0%)</option>
				
				<option value="file5">github.com/jufemaiz/go-aemo/nmi/participant.go (100.0%)</option>
				
				<option value="file6">github.com/jufemaiz/go-aemo/nmi/pattern.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package nmi

import (
        "fmt"
        "regexp"
)

var (
        allocationsUndefined = Allocations{}

        allocationsACTEWP = Allocations{
                Pattern(`^(NGGG[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(7001\d{6})$`),
        }

        allocationsAEMORESERVED = Allocations{
                Pattern(`^(880[1-5]\d{6})$`),
                Pattern(`^(9\d{9})$`),
        }

        allocationsAURORAP = Allocations{
                Pattern(`^(T000000(([0-4]\d{3})|(500[01])))$`),
                Pattern(`^(8000\d{6})$`),
                Pattern(`^(8590[23]\d{5})$`),
        }

        allocationsCITIPP = Allocations{
                Pattern(`^(VAAA[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(610[23]\d{6})$`),
        }

        allocationsCNRGYP = Allocations{
                Pattern(`^(NAAA[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(NBBB[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(NDDD[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(NFFF[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(4001\d{6})$`),
                Pattern(`^(4508\d{6})$`),
                Pattern(`^(4204\d{6})$`),
                Pattern(`^(4407\d{6})$`),
        }

        allocationsEASTERN = Allocations{
                Pattern(`^(VBBB[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(630[56]\d{6})$`),
        }

        allocationsENERGEXP = Allocations{
                Pattern(`^(QB\d{2}[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(31\d{8})$`),
        }

        allocationsENERGYAP = Allocations{
                Pattern(`^(NCCC[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(410[234]\d{6})$`),
        }

        allocationsERGONETP = Allocations{
                Pattern(`^(QAAA[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(QCCC[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(QDDD[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(QEEE[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(QFFF[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(QGGG[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(30\d{8})$`),
        }

        allocationsETSATP = Allocations{
                Pattern(`^(S[A-HJ-NP-Z\d]{3}W[A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(210200\d{4})$`),
        }

        allocationsEXEMPTNETWORKS = Allocations{
                Pattern(`^(NKKK[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(7102\d{6})$`),
        }

        allocationsFEDAIRPORTS = Allocations{
                Pattern(`^(NJJJNR[A-HJ-NP-Z\d]{4})$`),
        }

        allocationsGAS_NSW = Allocations{
                Pattern(`^(52\d{8})$`),
        }

        allocationsGAS_QLD = Allocations{
                Pattern(`^(54\d{8})$`),
        }

        allocationsGAS_SA = Allocations{
                Pattern(`^(55\d{8})$`),
        }

        allocationsGAS_TAS = Allocations{
                Pattern(`^(57\d{8})$`),
        }

        allocationsGAS_VIC = Allocations{
                Pattern(`^(53\d{8})$`),
        }

        allocationsGAS_WA = Allocations{
                Pattern(`^(56\d{8})$`),
        }

        allocationsGPUPP = Allocations{
                Pattern(`^(V[A-HJ-NP-Z\d]{3}W[A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(650900\d{4})$`),
        }

        allocationsHORIZONPOWER = Allocations{
                Pattern(`^(8021\d{6})$`),
        }

        allocationsINTEGP = Allocations{
                Pattern(`^(NEEE[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(431\d{7})$`),
        }

        allocationsNT_RESERVED = Allocations{
                Pattern(`^(250\d{7})$`),
        }

        allocationsPLINKP = Allocations{
                Pattern(`^(Q[A-HJ-NP-Z\d]{3}W[A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(320200\d{4})$`),
        }

        allocationsPOWCP = Allocations{
                Pattern(`^(VCCC[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(620[34]\d{6})$`),
        }

        allocationsSNOWY = Allocations{
                Pattern(`^(4708109\d{3})$`),
        }

        allocationsSOLARISP = Allocations{
                Pattern(`^(VDDD[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(6001\d{6})$`),
        }

        allocationsTRANSEND = Allocations{
                Pattern(`^(T[A-HJ-NP-Z\d]{3}W[A-HJ-NP-Z\d]{5})$`),
        }

        allocationsTRANSGP = Allocations{
                Pattern(`^(NTTT[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(460810[0-8]\d{3})$`),
        }

        allocationsUMPLP = Allocations{
                Pattern(`^(SAAA[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(SASMPL[\d]{4})$`),
                Pattern(`^(200[12]\d{6})$`),
        }

        allocationsUNITED = Allocations{
                Pattern(`^(VEEE[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(640[78]\d{6})$`),
        }

        allocationsWESTERNPOWER = Allocations{
                Pattern(`^(WAAA[A-HJ-NP-VX-Z\d][A-HJ-NP-Z\d]{5})$`),
                Pattern(`^(800[1-9]\d{6})$`),
                Pattern(`^(801\d{7})$`),
                Pattern(`^(8020\d{6})$`),
        }
)

// Allocations is an allocation of the NMI
type Allocations []Pattern

// Compile compiles all patterns.
func (a Allocations) Compile() ([]*regexp.Regexp, error) <span class="cov8" title="33">{
        resp := make([]*regexp.Regexp, len(a))

        for i, p := range a </span><span class="cov10" title="67">{
                pc, err := p.Compile()
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("pattern[%d]: '%s': %w", i, p.String(), ErrPatternInvalid)
                }</span>

                <span class="cov9" title="66">resp[i] = pc</span>
        }

        <span class="cov8" title="32">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package nmi

import (
        "fmt"
        "strings"
)

const (
        EnergyUndefined Energy = iota
        EnergyElectricity
        EnergyGas
)

var (
        energies = []Energy{
                EnergyUndefined,
                EnergyElectricity,
                EnergyGas,
        }

        Energy_name = map[Energy]string{
                EnergyUndefined:   "UNDEFINED",
                EnergyElectricity: "ELECTRICITY",
                EnergyGas:         "GAS",
        }

        Energy_value = map[string]Energy{
                "UNDEFINED":   EnergyUndefined,
                "ELECTRICITY": EnergyElectricity,
                "GAS":         EnergyGas,
        }
)

// Energy represents the type of energy for a nmi.
type Energy int32

// NewEnergy returns an energy based on the string provided.
func NewEnergy(s string) (Energy, error) <span class="cov6" title="5">{
        e, ok := Energy_value[strings.ToUpper(s)]
        if !ok </span><span class="cov1" title="1">{
                return EnergyUndefined, ErrEnergyInvalid
        }</span>

        <span class="cov5" title="4">return e, nil</span>
}

// String satisfies the stringer interface.
func (e Energy) GoString() string <span class="cov4" title="3">{
        return fmt.Sprintf("\"%s\"", e.String())
}</span>

// String satisfies the stringer interface.
func (e Energy) String() string <span class="cov10" title="13">{
        s, ok := Energy_name[e]
        if !ok </span><span class="cov3" title="2">{
                return Energy_name[EnergyUndefined]
        }</span>

        <span class="cov9" title="11">return s</span>
}

// Energies provides a slice of valid energies.
func Energies() []Energy <span class="cov1" title="1">{
        return energies
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package nmi

import (
        "fmt"
        "time"
)

// Meters a collection of meters, using a map, with the identifier.
type Meters map[string]*Meter

// Meter for a NMI
type Meter struct {
        Nmi                string           `json:"nmi"`
        Identifier         string           `json:"idenifier"`
        Registers          []*MeterRegister `json:"registers"`
        SerialNumber       *string          `json:"serialNumber"`
        FromDateTime       *time.Time       `json:"fromDateTime"`
        ToDateTime         *time.Time       `json:"toDateTime"`
        LastTestDate       *time.Time       `json:"lastTestDate"`
        AdditionalSiteInfo *string          `json:"additionalSiteInformation"`
        // Location                  string
        // Point                     int
        // Status                    Status
}

// GoString meets the gostring interface.
func (m *Meter) GoString() string <span class="cov10" title="18">{
        if m == nil </span><span class="cov1" title="1">{
                return "nil"
        }</span>

        <span class="cov9" title="17">str := fmt.Sprintf(
                "Meter{Nmi: \"%s\", Identifier: \"%s\", Registers: %#v",
                m.Nmi, m.Identifier, m.Registers,
        )

        if m.SerialNumber != nil </span><span class="cov1" title="1">{
                str += fmt.Sprintf(", SerialNumber: \"%s\"", *m.SerialNumber)
        }</span>

        <span class="cov9" title="17">str += "}"

        return str</span>
        // fmt.Sprintf(
        //         "Meter{"+
        //                 "Identifier: \"%s\", FromDateTime: \"%s\", ToDateTime: \"%s\", LastTestDate: \"%s\", "+
        //                 "SerialNumber: \"%s\", Registers: \"%#v\", AdditionalSiteInfo: \"%s\""+
        //                 "}",
        //         m.Identifier, m.FromDateTime.Format(time.RFC3339), m.ToDateTime.Format(time.RFC3339),
        //         m.LastTestDate.Format(time.RFC3339), m.SerialNumber, m.Registers, m.AdditionalSiteInfo,
        // )
}

// String meets the stringer interface.
func (m *Meter) String() string <span class="cov3" title="2">{
        if m == nil </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov1" title="1">return string(m.Identifier)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package nmi

import "fmt"

// MeterRegister for a Meter for a NMI
type MeterRegister struct {
        RegisterID        string `json:"registerID"`
        MeasurementStream string `json:"measurementStream"`
        NetworkTariffCode string `json:"networkTariffCode"`
        UnitOfMeasure     string `json:"unitOfMeasure"`
        TimeOfDay         string `json:"timeOfDay"`
        Multiplier        int    `json:"multiplier"`
        DialFormat        string `json:"dialFormat"`
        ControlledLoad    bool   `json:"controlledLoad"`
        ConsumptionType   string `json:"consumptionType"`
        Status            string `json:"status"`
}

// GoString meets the gostring interface.
func (mr *MeterRegister) GoString() string <span class="cov10" title="4">{
        if mr == nil </span><span class="cov1" title="1">{
                return "nil"
        }</span>

        <span class="cov8" title="3">return fmt.Sprintf(
                "MeterRegister{"+
                        "RegisterID: \"%s\", MeasurementStream: \"%s\", NetworkTariffCode: \"%s\", "+
                        "UnitOfMeasure: \"%s\", TimeOfDay: \"%s\", Multiplier: %d, "+
                        "DialFormat: \"%s\", ControlledLoad: %t, ConsumptionType: \"%s\", Status: \"%s\""+
                        "}",
                mr.RegisterID, mr.MeasurementStream, mr.NetworkTariffCode, mr.UnitOfMeasure,
                mr.TimeOfDay, mr.Multiplier, mr.DialFormat, mr.ControlledLoad, mr.ConsumptionType,
                mr.Status,
        )</span>
}

// String meets the stringer interface.
func (mr *MeterRegister) String() string <span class="cov5" title="2">{
        if mr == nil </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov1" title="1">return string(mr.RegisterID)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package nmi

import (
        "fmt"
        "regexp"
        "sort"

        "github.com/jufemaiz/go-aemo/region"
)

const (
        // NMICHECKSUMINVALID is returned when a valid checksum cannot be determined.
        NMICHECKSUMINVALID = -1
        // NmiLength is the standard length of a Nmi.
        NmiLength = 10
        // NmiValidPattern the pattern for valid Nmis.
        NmiValidPattern = `^([A-HJ-NP-Z\d]{10})`
)

var (
        // NmiValidRegexp is the regular expression that Nmi strings may contain.
        NmiValidRegexp = regexp.MustCompile(NmiValidPattern)
)

// Nmi is a national meter identifier as per AEMO.
// Ref:
// - https://aemo.com.au/-/media/files/electricity/nem/retail_and_metering/metering-procedures/2016/0610-0008-pdf.pdf
// -
type Nmi struct {
        Identifier                 string `json:"identifier"`
        MSATSDetail                string `json:"msatsDetail"`
        TransmissionNodeIdentifier TNI    `json:"tni"`
        DistributionLossFactorCode DLFC   `json:"dlfc"`
        CustomerClassificationCode string `json:"customerClassificationCode"`
        CustomerThresholdCode      string `json:"customerThresholdCode"`
        JurisdictionCode           string `json:"jurisdictionCode"`
        ClassificationCode         string `json:"classificationCode"`
        Meters                     Meters `json:"meters"`
        DataStreams                string `json:"datastreams"`
        // Address                    Address
        // Status                     Status
        // Roles       []*Role
}

// NmiChecksum calculates a Nmi's checksum.
func NmiChecksum(s string) int <span class="cov5" title="31">{
        n, err := NewNmi(s)
        if err != nil </span><span class="cov1" title="1">{
                return NMICHECKSUMINVALID
        }</span>

        <span class="cov5" title="30">return n.Checksum()</span>
}

// NewNmi returns a string as a Nmi along with an error if not valid.
func NewNmi(s string) (*Nmi, error) <span class="cov5" title="35">{
        n := &amp;Nmi{Identifier: s}
        if err := n.Validate(); err != nil </span><span class="cov2" title="4">{
                return nil, err
        }</span>

        <span class="cov5" title="31">return n, nil</span>
}

// GoString meets the gostring interface.
func (n *Nmi) GoString() string <span class="cov1" title="2">{
        return fmt.Sprintf("Nmi{Identifier: \"%s\"}", n.Identifier)
}</span>

// String meets the stringer interface.
func (n *Nmi) String() string <span class="cov7" title="262">{
        return string(n.Identifier)
}</span>

// Checksum returns the checksum of the provided Nmi.
func (n *Nmi) Checksum() int <span class="cov6" title="72">{
        if !n.Valid() </span><span class="cov1" title="2">{
                return NMICHECKSUMINVALID
        }</span>

        <span class="cov6" title="70">var c, s int64

        sumDig := func(n int64) int64 </span><span class="cov8" title="700">{
                var s int64

                for n != 0 </span><span class="cov10" title="1634">{
                        s += n % 10
                        n = n / 10
                }</span>

                <span class="cov8" title="700">return s</span>
        }

        <span class="cov6" title="70">chrs := []rune(n.Identifier)

        for i := len(chrs) - 1; i &gt;= 0; i = i - 1 </span><span class="cov8" title="700">{
                v := int64(chrs[i])
                if i%2 != 0 </span><span class="cov8" title="350">{
                        v = v * 2
                }</span>

                <span class="cov8" title="700">s = s + sumDig(v)</span>
        }

        <span class="cov6" title="70">c = (10 - (s % 10)) % 10

        return int(c)</span>
}

// ChecksumValid returns true if the provided checksum is valid.
func (n *Nmi) ChecksumValid(i int) bool <span class="cov3" title="11">{
        c := n.Checksum()
        if c == NMICHECKSUMINVALID </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="10">return i == c</span>
}

// Valid returns true if the Nmi is valid.
func (n *Nmi) Valid() bool <span class="cov6" title="72">{
        if err := n.Validate(); err != nil </span><span class="cov1" title="2">{
                return false
        }</span>

        <span class="cov6" title="70">return true</span>
}

// Validate checks if the Nmi is valid and returns the errors if not.
func (n *Nmi) Validate() error <span class="cov6" title="107">{
        if len(n.Identifier) != NmiLength </span><span class="cov1" title="2">{
                return fmt.Errorf("'%s': %w", n, ErrNmiInvalidLength)
        }</span>

        <span class="cov6" title="105">if !NmiValidRegexp.Match([]byte(n.Identifier)) </span><span class="cov2" title="4">{
                return fmt.Errorf("'%s': %w", n, ErrNmiInvalidChar)
        }</span>

        <span class="cov6" title="101">return nil</span>
}

// AllMeters returns all the meters for a Nmi.
func (n *Nmi) AllMeters() ([]*Meter, error) <span class="cov2" title="4">{
        if n == nil </span><span class="cov1" title="1">{
                return nil, ErrNmiNil
        }</span>

        <span class="cov2" title="3">meters := []*Meter{}
        for _, m := range n.Meters </span><span class="cov2" title="5">{
                if m == nil </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov2" title="4">meters = append(meters, m)</span>
        }

        <span class="cov2" title="3">sort.Slice(meters, func(i, j int) bool </span><span class="cov1" title="2">{
                return meters[i].Identifier &lt; meters[j].Identifier
        }</span>)

        <span class="cov2" title="3">return meters, nil</span>
}

// AddMeter adds a new meter, returning an error if already added.
func (n *Nmi) AddMeter(m *Meter) error <span class="cov2" title="5">{
        if n == nil </span><span class="cov1" title="1">{
                return ErrNmiNil
        }</span>

        <span class="cov2" title="4">if m == nil </span><span class="cov1" title="1">{
                return ErrMeterNil
        }</span>

        <span class="cov2" title="3">if m.Identifier == "" </span><span class="cov1" title="1">{
                return ErrNmiMeterIdentifierEmpty
        }</span>

        <span class="cov1" title="2">_, ok := n.Meters[m.Identifier]
        if ok </span><span class="cov1" title="1">{
                return fmt.Errorf("adding meter '%#v': %w", m, ErrNmiMeterFound)
        }</span>

        <span class="cov1" title="1">n.Meters[m.Identifier] = m

        return nil</span>
}

// RemoveMeter removes a meter, returning an error if not in the list.
func (n *Nmi) RemoveMeter(m *Meter) error <span class="cov2" title="5">{
        if n == nil </span><span class="cov1" title="1">{
                return ErrNmiNil
        }</span>

        <span class="cov2" title="4">if m == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("RemoveMeter: %w", ErrMeterNil)
        }</span>

        <span class="cov2" title="3">_, ok := n.Meters[m.Identifier]
        if !ok </span><span class="cov1" title="2">{
                return fmt.Errorf("removing meter '%s': %w", m.Identifier, ErrNmiMeterNotFound)
        }</span>

        <span class="cov1" title="1">delete(n.Meters, m.Identifier)

        return nil</span>
}

// Participant returns the pariticipant for the Nmi.
func (n *Nmi) Participant() (Participant, error) <span class="cov2" title="5">{
        if n == nil </span><span class="cov1" title="1">{
                return ParticipantUndefined, ErrNmiNil
        }</span>

        <span class="cov2" title="4">for _, p := range Participants() </span><span class="cov6" title="120">{
                for _, pat := range p.Allocations() </span><span class="cov7" title="252">{
                        if pat.Match(n.String()) </span><span class="cov1" title="2">{
                                return p, nil
                        }</span>
                }
        }

        <span class="cov1" title="2">return ParticipantUndefined, ErrParticipantInvalid</span>
}

// Region returns the region based on the allocation.
func (n *Nmi) Region() (region.Region, error) <span class="cov2" title="3">{
        if n == nil </span><span class="cov1" title="1">{
                return region.RegionUndefined, ErrNmiNil
        }</span>

        <span class="cov1" title="2">p, err := n.Participant()
        if err != nil </span><span class="cov1" title="1">{
                return region.RegionUndefined, fmt.Errorf("'%s': %w", n, err)
        }</span>

        <span class="cov1" title="1">return p.Region(), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package nmi

import (
        "fmt"
        "strings"

        "github.com/jufemaiz/go-aemo/region"
)

const (
        ParticipantUndefined Participant = iota
        ParticipantACTEWP
        ParticipantAEMORESERVED
        ParticipantAURORAP
        ParticipantCITIPP
        ParticipantCNRGYP
        ParticipantEASTERN
        ParticipantENERGEXP
        ParticipantENERGYAP
        ParticipantERGONETP
        ParticipantETSATP
        ParticipantEXEMPTNETWORKS
        ParticipantFEDAIRPORTS
        ParticipantGAS_NSW
        ParticipantGAS_QLD
        ParticipantGAS_SA
        ParticipantGAS_TAS
        ParticipantGAS_VIC
        ParticipantGAS_WA
        ParticipantGPUPP
        ParticipantHORIZONPOWER
        ParticipantINTEGP
        ParticipantNT_RESERVED
        ParticipantPLINKP
        ParticipantPOWCP
        ParticipantSNOWY
        ParticipantSOLARISP
        ParticipantTRANSEND
        ParticipantTRANSGP
        ParticipantUMPLP
        ParticipantUNITED
        ParticipantWESTERNPOWER
)

var (
        participants = []Participant{
                ParticipantACTEWP,
                ParticipantAEMORESERVED,
                ParticipantAURORAP,
                ParticipantCITIPP,
                ParticipantCNRGYP,
                ParticipantEASTERN,
                ParticipantENERGEXP,
                ParticipantENERGYAP,
                ParticipantERGONETP,
                ParticipantETSATP,
                ParticipantEXEMPTNETWORKS,
                ParticipantFEDAIRPORTS,
                ParticipantGAS_NSW,
                ParticipantGAS_QLD,
                ParticipantGAS_SA,
                ParticipantGAS_TAS,
                ParticipantGAS_VIC,
                ParticipantGAS_WA,
                ParticipantGPUPP,
                ParticipantHORIZONPOWER,
                ParticipantINTEGP,
                ParticipantNT_RESERVED,
                ParticipantPLINKP,
                ParticipantPOWCP,
                ParticipantSNOWY,
                ParticipantSOLARISP,
                ParticipantTRANSEND,
                ParticipantTRANSGP,
                ParticipantUMPLP,
                ParticipantUNITED,
                ParticipantWESTERNPOWER,
        }

        Participant_name = map[Participant]string{
                ParticipantUndefined:      "UNDEFINED",
                ParticipantACTEWP:         "ACTEWP",
                ParticipantAEMORESERVED:   "AEMORESERVED",
                ParticipantAURORAP:        "AURORAP",
                ParticipantCITIPP:         "CITIPP",
                ParticipantCNRGYP:         "CNRGYP",
                ParticipantEASTERN:        "EASTERN",
                ParticipantENERGEXP:       "ENERGEXP",
                ParticipantENERGYAP:       "ENERGYAP",
                ParticipantERGONETP:       "ERGONETP",
                ParticipantETSATP:         "ETSATP",
                ParticipantEXEMPTNETWORKS: "EXEMPTNETWORKS",
                ParticipantFEDAIRPORTS:    "FEDAIRPORTS",
                ParticipantGAS_NSW:        "GAS_NSW",
                ParticipantGAS_QLD:        "GAS_QLD",
                ParticipantGAS_SA:         "GAS_SA",
                ParticipantGAS_TAS:        "GAS_TAS",
                ParticipantGAS_VIC:        "GAS_VIC",
                ParticipantGAS_WA:         "GAS_WA",
                ParticipantGPUPP:          "GPUPP",
                ParticipantHORIZONPOWER:   "HORIZONPOWER",
                ParticipantINTEGP:         "INTEGP",
                ParticipantNT_RESERVED:    "NT_RESERVED",
                ParticipantPLINKP:         "PLINKP",
                ParticipantPOWCP:          "POWCP",
                ParticipantSNOWY:          "SNOWY",
                ParticipantSOLARISP:       "SOLARISP",
                ParticipantTRANSEND:       "TRANSEND",
                ParticipantTRANSGP:        "TRANSGP",
                ParticipantUMPLP:          "UMPLP",
                ParticipantUNITED:         "UNITED",
                ParticipantWESTERNPOWER:   "WESTERNPOWER",
        }

        Participant_value = map[string]Participant{
                "UNDEFINED":      ParticipantUndefined,
                "ACTEWP":         ParticipantACTEWP,
                "AEMORESERVED":   ParticipantAEMORESERVED,
                "AURORAP":        ParticipantAURORAP,
                "CITIPP":         ParticipantCITIPP,
                "CNRGYP":         ParticipantCNRGYP,
                "EASTERN":        ParticipantEASTERN,
                "ENERGEXP":       ParticipantENERGEXP,
                "ENERGYAP":       ParticipantENERGYAP,
                "ERGONETP":       ParticipantERGONETP,
                "ETSATP":         ParticipantETSATP,
                "EXEMPTNETWORKS": ParticipantEXEMPTNETWORKS,
                "FEDAIRPORTS":    ParticipantFEDAIRPORTS,
                "GAS_NSW":        ParticipantGAS_NSW,
                "GAS_QLD":        ParticipantGAS_QLD,
                "GAS_SA":         ParticipantGAS_SA,
                "GAS_TAS":        ParticipantGAS_TAS,
                "GAS_VIC":        ParticipantGAS_VIC,
                "GAS_WA":         ParticipantGAS_WA,
                "GPUPP":          ParticipantGPUPP,
                "HORIZONPOWER":   ParticipantHORIZONPOWER,
                "INTEGP":         ParticipantINTEGP,
                "NT_RESERVED":    ParticipantNT_RESERVED,
                "PLINKP":         ParticipantPLINKP,
                "POWCP":          ParticipantPOWCP,
                "SNOWY":          ParticipantSNOWY,
                "SOLARISP":       ParticipantSOLARISP,
                "TRANSEND":       ParticipantTRANSEND,
                "TRANSGP":        ParticipantTRANSGP,
                "UMPLP":          ParticipantUMPLP,
                "UNITED":         ParticipantUNITED,
                "WESTERNPOWER":   ParticipantWESTERNPOWER,
        }

        participantRegions = []region.Region{
                region.RegionUndefined,
                region.RegionACT,
                region.RegionUndefined,
                region.RegionTAS,
                region.RegionVIC,
                region.RegionNSW,
                region.RegionVIC,
                region.RegionQLD,
                region.RegionNSW,
                region.RegionQLD,
                region.RegionSA,
                region.RegionUndefined,
                region.RegionNSW,
                region.RegionNSW,
                region.RegionQLD,
                region.RegionSA,
                region.RegionTAS,
                region.RegionVIC,
                region.RegionWA,
                region.RegionVIC,
                region.RegionWA,
                region.RegionNSW,
                region.RegionNT,
                region.RegionQLD,
                region.RegionVIC,
                region.RegionNSW,
                region.RegionVIC,
                region.RegionTAS,
                region.RegionNSW,
                region.RegionSA,
                region.RegionVIC,
                region.RegionWA,
        }

        ParticipantIDs = []string{
                "UNDEFINED",
                "ACTEWP",
                "AEMORESERVED",
                "AURORAP",
                "CITIPP",
                "CNRGYP",
                "EASTERN",
                "ENERGEXP",
                "ENERGYAP",
                "ERGONETP",
                "ETSATP",
                "EXEMPTNETWORKS",
                "FEDAIRPORTS",
                "GAS_NSW",
                "GAS_QLD",
                "GAS_SA",
                "GAS_TAS",
                "GAS_VIC",
                "GAS_WA",
                "GPUPP",
                "HORIZONPOWER",
                "INTEGP",
                "NT_RESERVED",
                "PLINKP",
                "POWCP",
                "SNOWY",
                "SOLARISP",
                "TRANSEND",
                "TRANSGP",
                "UMPLP",
                "UNITED",
                "WESTERNPOWER",
        }

        participantLongNames = []string{
                "UNDEFINED",
                "Icon Distribution Investments Limited and Jemena Networks (ACT) Pty Ltd Trading as Evoenergy â€“ DNSP &amp; TNSP",
                "AEMO Reserved",
                "TasNetworks",
                "CitiPower",
                "Essential Energy",
                "SP AusNet",
                "ENERGEX Limited",
                "Ausgrid",
                "Ergon Energy Corporation",
                "ElectraNet SA",
                "Exempt Networks - various",
                "Federal Airports Corporation (Sydney Airport)",
                "GAS NSW",
                "GAS QLD",
                "GAS SA",
                "GAS TAS",
                "GAS VIC",
                "GAS WA",
                "SP AusNet TNSP",
                "Horizon Power",
                "Endeavour Energy",
                "Northern Territory Reserved Block",
                "Qld Electricity Transmission Corp (Powerlink)",
                "PowerCor Australia",
                "Snowy Hydro Ltd",
                "Jemena  Electricity Networks (VIC)",
                "TasNetworks",
                "TransGrid",
                "SA Power Networks",
                "United Energy Distribution",
                "Western Power",
        }

        participantShortNames = []string{
                "UNDEFINED",
                "Evoenergy",
                "AEMO Reserved",
                "TasNetworks",
                "CitiPower",
                "Essential Energy",
                "SP AusNet DNSP",
                "Energex",
                "Ausgrid",
                "Ergon Energy",
                "ElectraNet SA",
                "Exempt Networks - various",
                "Sydney Airport",
                "GAS NSW",
                "GAS QLD",
                "GAS SA",
                "GAS TAS",
                "GAS VIC",
                "GAS WA",
                "SP AusNet TNSP",
                "Horizon Power",
                "Endeavour Energy",
                "Northern Territory Reserved Block",
                "Powerlink",
                "PowerCor",
                "Snowy Hydro",
                "Jemena",
                "TasNetworks",
                "TransGrid",
                "SA Power Networks",
                "United Energy",
                "Western Power",
        }

        participantEnergies = []Energy{
                EnergyUndefined,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyGas,
                EnergyGas,
                EnergyGas,
                EnergyGas,
                EnergyGas,
                EnergyGas,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
                EnergyElectricity,
        }

        participantAllocations = []Allocations{
                allocationsUndefined,
                allocationsACTEWP,
                allocationsAEMORESERVED,
                allocationsAURORAP,
                allocationsCITIPP,
                allocationsCNRGYP,
                allocationsEASTERN,
                allocationsENERGEXP,
                allocationsENERGYAP,
                allocationsERGONETP,
                allocationsETSATP,
                allocationsEXEMPTNETWORKS,
                allocationsFEDAIRPORTS,
                allocationsGAS_NSW,
                allocationsGAS_QLD,
                allocationsGAS_SA,
                allocationsGAS_TAS,
                allocationsGAS_VIC,
                allocationsGAS_WA,
                allocationsGPUPP,
                allocationsHORIZONPOWER,
                allocationsINTEGP,
                allocationsNT_RESERVED,
                allocationsPLINKP,
                allocationsPOWCP,
                allocationsSNOWY,
                allocationsSOLARISP,
                allocationsTRANSEND,
                allocationsTRANSGP,
                allocationsUMPLP,
                allocationsUNITED,
                allocationsWESTERNPOWER,
        }
)

// Participant is an index for the participant.
type Participant int32

// ParticipantInfo provides structure for participant information.
type ParticipantInfo struct {
        Participant   Participant   `json:"participant"`
        ParticipantID string        `json:"participantID"`
        Region        region.Region `json:"region"`
        LongName      string        `json:"longName"`
        ShortName     string        `json:"shortName"`
        Energy        Energy        `json:"energy"`
        Allocations   Allocations   `json:"allocations"`
}

// Participants returns all valid participants.
func Participants() []Participant <span class="cov3" title="5">{
        return participants
}</span>

// ParticipantsForRegion returns the pariticipants that operate in a region.
func ParticipantsForRegion(r region.Region) []Participant <span class="cov4" title="9">{
        resp := []Participant{}

        for _, p := range participants </span><span class="cov9" title="279">{
                if p.Region() == r </span><span class="cov6" title="31">{
                        resp = append(resp, p)
                }</span>
        }

        <span class="cov4" title="9">return resp</span>
}

// NewParticipant returns a participant for a string (AEMO Participant ID).
func NewParticipant(s string) (Participant, error) <span class="cov6" title="33">{
        p, ok := Participant_value[strings.ToUpper(s)]
        if !ok </span><span class="cov1" title="1">{
                return ParticipantUndefined, ErrParticipantInvalid
        }</span>

        <span class="cov6" title="32">return p, nil</span>
}

// Valid returns true if a valid participant.
func (p Participant) Valid() bool <span class="cov4" title="11">{
        if _, ok := Participant_name[p]; !ok </span><span class="cov2" title="3">{
                return false
        }</span>

        <span class="cov4" title="8">return true</span>
}

// GoString meets the gostring interface.
func (p Participant) GoString() string <span class="cov3" title="4">{
        if !p.Valid() </span><span class="cov1" title="1">{
                return ParticipantUndefined.GoString()
        }</span>

        <span class="cov2" title="3">return fmt.Sprintf(
                "Participant{Participant: %d, ParticipantID: \"%s\", Region: %#v, LongName: \"%s\", ShortName: \"%s\", Energy: \"%s\", Allocations: %#v}",
                p, p.ParticipantID(), p.Region(), p.LongName(), p.ShortName(), p.Energy().String(), p.Allocations(),
        )</span>
}

// String meets the stringer interface.
func (p Participant) String() string <span class="cov3" title="4">{
        if !p.Valid() </span><span class="cov1" title="1">{
                return ParticipantUndefined.String()
        }</span>

        <span class="cov2" title="3">return p.ParticipantID()</span>
}

// Info struct for a participant.
func (p Participant) Info() (*ParticipantInfo, error) <span class="cov2" title="3">{
        if !p.Valid() || p == ParticipantUndefined </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("participant '%d': %w", p, ErrParticipantInvalid)
        }</span>

        <span class="cov1" title="1">return &amp;ParticipantInfo{
                Participant:   p,
                ParticipantID: p.ParticipantID(),
                Region:        p.Region(),
                LongName:      p.LongName(),
                ShortName:     p.ShortName(),
                Energy:        p.Energy(),
                Allocations:   p.Allocations(),
        }, nil</span>
}

// ParticipantID returns the Participant ID.
func (p Participant) ParticipantID() string <span class="cov6" title="39">{
        return ParticipantIDs[p]
}</span>

// Region returns the Participant's Region.
func (p Participant) Region() region.Region <span class="cov10" title="284">{
        return participantRegions[p]
}</span>

// LongName returns the long (full) name of the participant.
func (p Participant) LongName() string <span class="cov3" title="4">{
        return participantLongNames[p]
}</span>

// ShortName returns the short (useful) name of the participant.
func (p Participant) ShortName() string <span class="cov3" title="4">{
        return participantShortNames[p]
}</span>

// Energy returns the energy type of the participant's allocations.
func (p Participant) Energy() Energy <span class="cov3" title="4">{
        return participantEnergies[p]
}</span>

// Allocations returns the participant's allocations.
func (p Participant) Allocations() Allocations <span class="cov8" title="124">{
        return participantAllocations[p]
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package nmi

import (
        "fmt"
        "regexp"
)

// Pattern for making regexes nicer with pattern matching.
type Pattern string

// NewPattern validates a new pattern, return invalid pattern if required.
func NewPattern(s string) (Pattern, error) <span class="cov2" title="2">{
        _, err := regexp.Compile(s)
        if err != nil </span><span class="cov1" title="1">{
                return Pattern(s), fmt.Errorf("pattern '%s': %w", s, ErrPatternInvalid)
        }</span>

        <span class="cov1" title="1">return Pattern(s), nil</span>
}

// Compile compiles the pattern, returning the regexp and an error.
func (p Pattern) Compile() (*regexp.Regexp, error) <span class="cov9" title="322">{
        return regexp.Compile(p.String())
}</span>

// String returns the pattern as a string.
func (p Pattern) String() string <span class="cov10" title="323">{
        return string(p)
}</span>

// Match returns true if the pattern matches a given string.
func (p Pattern) Match(s string) bool <span class="cov9" title="255">{
        regex, err := p.Compile()
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov9" title="254">return regex.Match([]byte(s))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
